<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">(function (global, factory) {
  typeof exports === &#39;object&#39; &amp;&amp; typeof module !== &#39;undefined&#39; ? factory(exports, require(&#39;tickjs&#39;)) :
  typeof define === &#39;function&#39; &amp;&amp; define.amd ? define([&#39;exports&#39;, &#39;tickjs&#39;], factory) :
  (factory((global.Z = {}),null));
}(this, (function (exports,Tick) { &#39;use strict&#39;;

  Tick = Tick &amp;&amp; Tick.hasOwnProperty(&#39;default&#39;) ? Tick[&#39;default&#39;] : Tick;

<span id='global-method-wxPreviewImage'>  /**
</span>   * 微信图片预览
   * @author   daben&lt;dabennn07@gmail.com&gt;
   * @param     {Object|String}            params
   * @param     {String} [params.current]  需要显示的图片的url
   * @param     {Array} [params.images]  所有图片的数组
   * @return   {Boolean}               成功为true, 失败为false
   *
   *    @example
   *    wxPreviewImage({
   *      current: &#39;http://xxxxxx.xxx.xxxx&#39;,
   *      images: [&#39;http://xxxxx.xxxx.xxx&#39;, &#39;http://xxx.xxxx.xxxx&#39;]
   *    })
   */
  function wxPreviewImage() {
    var params = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : {};

    var current = void 0;
    var images = [];

    if (typeof params === &#39;string&#39;) {
      current = params;
      images = [current];
    } else {
      current = params.current;
      images = params.images.map(function (val) {
        return val.image_url;
      });
    }
    if (typeof WeixinJSBridge === &#39;undefined&#39;) {
      return false;
    }

    if (!current || !images) {
      return false;
    }
    wx.previewImage({
      current: current,
      urls: images
    });

    return true;
  }

<span id='global-cfg-env'>  /**
</span>   * 判断环境
   * @cfg {Object} env
   * @cfg {Function} [env.isWeChat] 判断是否微信ua
   * @cfg {Function} [env.isCosmeapp] 判断是否App ua
   * @cfg {Function} [env.isIOS] 判断是否ios ua
   * @cfg {Function} [env.isAndroid] 判断是否安卓ua
   * @cfg {Function} [env.isUC] 判断是否uc浏览器ua
   * @cfg {Function} [env.isBroswer] 判断是否是浏览器环境
   */
  var env = {
    isWeChat: function isWeChat() {
      return (/MicroMessenger/i.test(navigator.userAgent)
      );
    },
    isCosmeapp: function isCosmeapp() {
      return (/Cosmeapp/i.test(navigator.userAgent)
      );
    },
    isIOS: function isIOS() {
      return (/\(i[^;]+;( U;)? CPU.+Mac OS X/i.test(navigator.userAgent)
      );
    },
    isAndroid: function isAndroid() {
      return (/Android/.test(navigator.userAgent) || /Linux/.test(navigator.userAgent)
      );
    },
    isUC: function isUC() {
      return (/UCBrowser/i.test(navigator.userAgent)
      );
    },
    isBroswer: function isBroswer() {
      return typeof window !== &#39;undefined&#39;;
    }
  };



  var module$1 = /*#__PURE__*/Object.freeze({
    env: env,
    wxPreviewImage: wxPreviewImage
  });

<span id='global-method-is'>  /**
</span>   * 判断类型
   * @author   daben&lt;dabennn07@gmail.com&gt;
   * @param    {*}                        o     The value to check.
   * @param    {String}                   type  type string, like &#39;Number&#39;, &#39;Object&#39;
   * @return   {Boolean}                  true if the vaule is same as &#39;type string&#39;, else false.
   */
  function is(o, type) {
    return Object.prototype.toString.call(o) === &#39;[object &#39; + type + &#39;]&#39;;
  }

  function isString(str) {
    return typeof str === &#39;string&#39;;
  }

  function isNumberString(str) {
    return isString(str) &amp;&amp; /^\d+$/.test(str);
  }

  function isFunction(func) {
    return typeof func === &#39;function&#39;;
  }

  function isBoolean(bool) {
    return is(bool, &#39;Boolean&#39;);
  }

  function isNull(p) {
    return p === null;
  }

  function isUndefined(p) {
    return p === undefined;
  }

  var _typeof = typeof Symbol === &quot;function&quot; &amp;&amp; typeof Symbol.iterator === &quot;symbol&quot; ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj &amp;&amp; typeof Symbol === &quot;function&quot; &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? &quot;symbol&quot; : typeof obj;
  };

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError(&quot;Cannot call a class as a function&quot;);
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i &lt; props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if (&quot;value&quot; in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i &lt; arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };

<span id='global-method-isEmptyObjectLike'>  /**
</span>   * 是否是空对象或类对象
   * @author   daben&lt;dabennn07@gmail.com&gt;
   * @param    {*}                   obj  The value to check.
   * @return   {Boolean}             &#39;true&#39; if value is emptyObjectLike, else &#39;false&#39;.
   */
  function isEmptyObjectLike(obj) {
    if ((typeof obj === &#39;undefined&#39; ? &#39;undefined&#39; : _typeof(obj)) !== &#39;object&#39; || obj === null) {
      return false;
    }
    for (var p in obj) {
      return false;
    }
    return true;
  }
<span id='global-method-isObject'>  /**
</span>   * 是否是对象
   * @author   daben&lt;dabennn07@gmail.com&gt;
   * @param    {*}                   obj  The value to check.
   * @return   {Boolean}             &#39;true&#39; if value is Object, else &#39;false&#39;.
   */
  function isObject(obj) {
    return is(obj, &#39;Object&#39;);
  }
<span id='global-method-isObjectLike'>  /**
</span>   * 是否是typeof值为&#39;object&#39;或&#39;function&#39;的对象
   * @author   daben&lt;dabennn07@gmail.com&gt;
   * @param    {*}                   obj  The value to check.
   * @return   {Boolean}             &#39;true&#39; if value is ObjectLike, else &#39;false&#39;.
   */
  function isObjectLike(obj) {
    var type = typeof obj === &#39;undefined&#39; ? &#39;undefined&#39; : _typeof(obj);
    return obj !== null &amp;&amp; (type === &#39;object&#39; || type === &#39;function&#39;);
  }
<span id='global-method-isEmptyObject'>  /**
</span>   * 是否是空对象
   * @author   daben&lt;dabennn07@gmail.com&gt;
   * @param    {*}                   obj  The value to check.
   * @return   {Boolean}             &#39;true&#39; if value is emptyObject, else &#39;false&#39;.
   */
  function isEmptyObject(obj) {
    return isObject(obj) &amp;&amp; isEmptyObjectLike(obj);
  }

<span id='global-method-isArray'>  /**
</span>   * 是否是数组
   * @author   daben&lt;dabennn07@gmail.com&gt;
   * @param    {*}                   arr  The value to check.
   * @return   {Boolean}             &#39;true&#39; if the value is Array, else &#39;false&#39;.
   */
  var isArray = Array.isArray || function (arr) {
    return is(arr, &#39;Array&#39;);
  };

<span id='global-method-isEmptyArray'>  /**
</span>   * 是否是空数组
   * @author   daben&lt;dabennn07@gmail.com&gt;
   * @param    {*}                   arr The value to check.
   * @return   {Boolean}             &#39;true&#39; if the value is emptyArray, else &#39;false&#39;.
   */
  function isEmptyArray(arr) {
    return isArray(arr) &amp;&amp; isEmptyObjectLike(arr);
  }

<span id='global-method-isNumber'>  /**
</span>   * 是否是数字
   * @author   daben&lt;dabennn07@gmail.com&gt;
   * @param    {*}                   num  The value to check.
   * @return   {Boolean}             &#39;true&#39; if the value is Number, else &#39;false&#39;.
   */
  function isNumber(num) {
    return is(num, &#39;Number&#39;);
  }
<span id='global-method-isFloatNumber'>  /**
</span>   * 是否是浮点数
   * @author   daben&lt;dabennn07@gmail.com&gt;
   * @param    {*}                   num  The value to check.
   * @return   {Boolean}             &#39;true&#39; if the value is floatNumber, else &#39;false&#39;.
   */
  function isFloatNumber(num) {
    return isNumber(num) &amp;&amp; num !== parseInt(num, 10);
  }
<span id='global-method-isEvenNumber'>  /**
</span>   * 是否是偶数
   * @author   daben&lt;dabennn07@gmail.com&gt;
   * @param    {*}                   num  The value to check.
   * @return   {Boolean}             &#39;true&#39; if the value is evenNumber, else &#39;false&#39;.
   */
  function isEvenNumber(num) {
    return isNumber(num) &amp;&amp; !(num % 2);
  }



  var type = /*#__PURE__*/Object.freeze({
    is: is,
    isString: isString,
    isNumberString: isNumberString,
    isFunction: isFunction,
    isBoolean: isBoolean,
    isNull: isNull,
    isUndefined: isUndefined,
    isArray: isArray,
    isEmptyArray: isEmptyArray,
    isEmptyObjectLike: isEmptyObjectLike,
    isObject: isObject,
    isObjectLike: isObjectLike,
    isEmptyObject: isEmptyObject,
    isNumber: isNumber,
    isFloatNumber: isFloatNumber,
    isEvenNumber: isEvenNumber
  });

<span id='global-method-firstUpper'>  /**
</span>   * 首字母大写
   * @author   daben&lt;dabennn07@gmail.com&gt;
   * @param    {String}                   str  string to handle
   * @return   {String}                        new string
   */
  function firstUpper(str) {
    return str.replace(/^[a-zA-Z]/, function (s) {
      return s.toUpperCase();
    });
  }
<span id='global-method-trim'>  /**
</span>   * 去除字符串头尾空格
   * @author   daben&lt;dabennn07@gmail.com&gt;
   * @param    {String}                   str  string to transform
   * @return   {String}                        new string
   */
  function trim(str) {
    return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, &#39;&#39;);
  }
<span id='global-method-trimStart'>  /**
</span>   * 去除字符串头部空格
   * @author   daben&lt;dabennn07@gmail.com&gt;
   * @param    {String}                   str  string to transform
   * @return   {String}                        new string
   */
  function trimStart(str) {
    return str.replace(/^[\s\uFEFF\xA0]+/, &#39;&#39;);
  }
<span id='global-method-trimEnd'>  /**
</span>   * 去除字符串尾部空格
   * @author   daben&lt;dabennn07@gmail.com&gt;
   * @param    {String}                   str  string to transform
   * @return   {String}                        new string
   */
  function trimEnd(str) {
    return str.replace(/[\s\uFEFF\xA0]+$/, &#39;&#39;);
  }
<span id='global-method-camelCase'>  /**
</span>   * 转换字符串为驼峰命名法
   * @author   daben&lt;dabennn07@gmail.com&gt;
   * @param    {String}                   str  string to transform
   * @return   {String}                        new string
   */
  function camelCase(str) {
    return trim(str).replace(/([^\w]|_)+([a-z])/g, function (s, s1, s2) {
      return s2.toUpperCase();
    }).replace(/[^\w]|_/g, &#39;&#39;);
  }
<span id='global-method-capitalize'>  /**
</span>   * 转换字符串为首字母大写形式
   * @author   daben&lt;dabennn07@gmail.com&gt;
   * @param    {String}                   str  string to transform
   * @return   {String}                        new string
   */
  function capitalize(str) {
    return firstUpper(trim(str).toLowerCase());
  }

<span id='global-method-random'>  /**
</span>   * 生成一定范围内的随机数
   * @author   daben&lt;dabennn07@gmail.com&gt;
   * @param    {Number}                   start  start of range
   * @param    {Number}                   end    end of range
   * @param    {Boolean}                  int    result is int if true, else is float
   *
   * @example
   * random(7) // [0-7) float
   * random(7, 10)  // [7-10) float
   * random(7, 10, true) // [7-10] int
   *
   * @return   {Number}
   */
  function random() {
    var start = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : 0;
    var end = arguments[1];
    var int = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : false;

    if (arguments.length === 1 &amp;&amp; isNumber(start)) {
      end = start;
      start = 0;
    }
    if (is(end, &#39;Boolean&#39;)) {
      int = end;
      end = start;
      start = 0;
    }
    if (!isNumber(start) || !isNumber(end)) {
      throw new TypeError(&#39;Expected a number&#39;);
    }
    var baseRandom = Math.random() * (end - start);
    if (int) {
      baseRandom = Math.ceil(baseRandom);
    }
    return baseRandom + start;
  }
<span id='global-method-weightedRandom'>  /**
</span>   * 生成加权随机数
   * @param {Array|Object} weights 加权列表
   *
   * @example
   *    weightedRandom([3, 2, 2, 1]); // 返回下表0、1、2、3中的一项
   *    weightedRandom({ A: 3, B: 4, c: 1 }); // 返回键A、B、c中的一项
   *
   * @return {Number|String} 返回一个数组下标或对象的键
   */
  function weightedRandom(weights) {
    if (!isArray(weights) &amp;&amp; !isObject(weights)) {
      throw TypeError(&#39;Invalid type of &#39; + weights + &#39;,must be Array or Object&#39;);
    }
    var result = 0;
    function _randomIndex(l) {
      var sum = l.reduce(function (a, b) {
        return a + b;
      });
      var r = random(0, sum, true);
      var cur = 0;
      var res = 0;
      for (var i = 0; i &lt; l.length; i++) {
        cur += l[i];
        if (r &lt;= cur) {
          res = i;
          break;
        }
      }
      return res;
    }
    if (isArray(weights)) {
      weights = Array.prototype.slice.call(weights);
      result = _randomIndex(weights);
    } else if (isObject(weights)) {
      var keys = [];
      var values = [];
      for (var p in weights) {
        keys.push(p);
        values.push(weights[p]);
      }
      result = keys[_randomIndex(values)];
    }
    return result;
  }

<span id='global-method-list'>  /**
</span>   * 列表快速生成
   * @author   daben&lt;dabennn07@gmail.com&gt;
   * @param    {Number}                   length length of list
   * @param    {Function|Number}          fn     a function to generate list item. if is Number, array will fill with it.
   * @return   {Array}                           new array
   */
  function list() {
    var length = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : 0;
    var fn = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : function () {};

    if (isNumber(fn)) {
      fn = Function(&#39;return &#39; + fn);
    }
    if (!is(fn, &#39;Function&#39;)) {
      throw new TypeError(&#39;Expected a Function&#39;);
    }
    return Array.from(Array(length), fn);
  }
<span id='global-method-randomItem'>  /**
</span>   * 随机返回数组中的一项
   * @author   daben&lt;dabennn07@gmail.com&gt;
   * @param    {Array}                   arr  an array
   * @return   {*}                            random item of array
   */
  function randomItem() {
    var arr = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : [];

    if (!isArray(arr)) {
      throw new TypeError(&#39;Expected an Array&#39;);
    }
    if (isEmptyArray(arr)) {
      return undefined;
    }
    return arr[random(arr.length - 1, true)];
  }

  var objList = [];

  function copyObjectLike(value) {
    var newObj = new value.constructor();
    var p = void 0;
    objList.push(value);

    for (p in value) {
      var index = objList.indexOf(value[p]);
      if (index &gt; -1) {
        // 处理循环引用
        newObj[p] = objList[index];
      } else {
        newObj[p] = deepClone(value[p]);
      }
    }
    return newObj;
  }

<span id='global-method-deepClone'>  /**
</span>   * 对象、数组深拷贝
   * @param {*} value 需要拷贝的对象
   * @example
   *    deepClone({ a: 1, b: [1, 2] });
   *
   * @return {*} 新的对象或数组，非{}、[]数据原样返回
   */
  function deepClone(value) {
    if (!isObjectLike(value)) return value;
    if (isArray(value) || isObject(value)) {
      return copyObjectLike(value);
    }
    return value;
  }

<span id='Storage'>  /**
</span>   * 本地储存
   * @class Storage
   * @param {String} key localStorage键
   *
   *    @example
   *    const store = new Storage(&#39;store_key&#39;);
   *    store.add({ a: 1 });
   *    store.set(&#39;a&#39;, 2);
   *    let a = store.get(&#39;a&#39;); // 2
   */

  var Storage = function () {
    function Storage(key) {
      classCallCheck(this, Storage);

      if (!isString(key)) {
        throw new TypeError(&#39;Storage Key must be String&#39;);
      }
      if (!key) {
        throw new Error(&#39;Empty String is not allow&#39;);
      }
      this.STORAGE_KEY = key;

      this._init();
    }

    createClass(Storage, [{
      key: &#39;_init&#39;,
      value: function _init() {
        var value = localStorage[this.STORAGE_KEY];
        if (!value) {
          Storage.setItem(this.STORAGE_KEY, &#39;&#39;);
        }
      }
<span id='Storage-method-'>      /**
</span>       * 添加数据
       * @param {Object} obj 对象形式的数据
       * @return this
       */

    }, {
      key: &#39;add&#39;,
      value: function add() {
        var obj = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : {};

        if (!isObject(obj)) throw new TypeError(&#39;Invalid Object: &#39; + obj);
        try {
          var storage = Storage.getItem(this.STORAGE_KEY);
          if (storage) {
            obj = Object.assign(JSON.parse(storage), obj);
          }
          Storage.setItem(this.STORAGE_KEY, JSON.stringify(obj));
        } catch (e) {
          throw new Error(e);
        }
        return this;
      }
<span id='Storage-method-'>      /**
</span>       * 根据键设置数据
       * @param {String} key 键
       * @param {Any} value 值
       */

    }, {
      key: &#39;set&#39;,
      value: function set$$1(key, value) {
        var storage = this.get();
        storage[key] = value;
        Storage.setItem(this.STORAGE_KEY, JSON.stringify(storage));
        return this;
      }
<span id='Storage-method-'>      /**
</span>       * 根据键获取数据
       * @param {String} key 键
       */

    }, {
      key: &#39;get&#39;,
      value: function get$$1() {
        var key = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : &#39;&#39;;

        if (!isString(key)) return null;
        try {
          var storage = JSON.parse(Storage.getItem(this.STORAGE_KEY)) || {};
          if (!key) return storage;
          return storage[key];
        } catch (e) {
          console.warn(e);
          return {};
        }
      }
<span id='Storage-method-'>      /**
</span>       * 根据键删除数据
       * @param {String} key 键
       */

    }, {
      key: &#39;remove&#39;,
      value: function remove() {
        var key = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : &#39;&#39;;

        var storage = this.get();
        delete storage[key];
        Storage.setItem(this.STORAGE_KEY, JSON.stringify(storage));
        return this;
      }
<span id='Storage-property-'>      /**
</span>       * 清除数据
       */

    }, {
      key: &#39;clear&#39;,
      value: function clear() {
        Storage.removeItem(this.STORAGE_KEY);
      }
    }], [{
      key: &#39;setItem&#39;,
      value: function setItem() {
        var _localStorage;

        (_localStorage = localStorage).setItem.apply(_localStorage, arguments);
      }
    }, {
      key: &#39;getItem&#39;,
      value: function getItem() {
        var _localStorage2;

        return (_localStorage2 = localStorage).getItem.apply(_localStorage2, arguments);
      }
    }, {
      key: &#39;removeItem&#39;,
      value: function removeItem() {
        var _localStorage3;

        (_localStorage3 = localStorage).removeItem.apply(_localStorage3, arguments);
      }
    }, {
      key: &#39;clearAll&#39;,
      value: function clearAll() {
        localStorage.clear();
      }
    }]);
    return Storage;
  }();

<span id='ImageLoader'>  /**
</span>   * 图片加载器
   * @class ImageLoader
   * @param {String|Array} uri 图片路径或包含路径的数组
   * @param {Object} options 配置项
   * @param {Function} [options.compelete] 加载完成回调
   * @param {Function} [options.progress] 加载进度回调
   *
   *    @example
   *    const pics = [
   *      { name: xx, uri: xxx },
   *      { name: xx, uri: xxx },
   *    ];
   *    const loader = new ImageLoader(pics);
   *    loader.on(&#39;progress&#39;, (percent) =&gt; {
   *      xxx
   *    });
   *    loader.on(&#39;compelete&#39;, (suc, fail) =&gt; {
   *      xxx
   *    });
   *    loader.load();
   */

  var ImageLoader = function () {
    function ImageLoader() {
      classCallCheck(this, ImageLoader);

      this._loading = false;
      this._index = 0;
      this.list = [];
      this.queue = [];
      this.success = [];
      this.failed = [];
      this.count = 0;
      this.compelete = function () {};
      this.progress = function () {};

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key &lt; _len; _key++) {
        args[_key] = arguments[_key];
      }

      this._init(args);
    }

    createClass(ImageLoader, [{
      key: &#39;_init&#39;,
      value: function _init(args) {
        if (!args.length) return;
        if (isString(args[0]) || isArray(args[0])) {
          ths.add(args[0]);
        }
        if (isObject(args[1])) {
          if (!isFunction(args[1].compelete) || !isFunction(args[1].progress)) throw new TypeError(&#39;Must be a function&#39;);
          this.compelete = args[1].compelete;
          this.progress = args[1].progress;
        }
      }
<span id='ImageLoader-method-'>      /**
</span>       * 注册回调
       * @param {String} name 回调名称
       * @param {Function} cb 回调函数
       */

    }, {
      key: &#39;on&#39;,
      value: function on(name) {
        var cb = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : function () {};

        if (!isFunction(cb)) throw new TypeError(cb + &#39;is not a function&#39;);
        if (name !== &#39;compelete&#39; &amp;&amp; name !== &#39;progress&#39;) return;
        this[name] = cb;
      }
<span id='ImageLoader-method-'>      /**
</span>       * 添加图片
       * @param {String|Array} uri 图片路径或包含路径的数组
       * @example
       * 接受字符串形式的路径 add(&#39;xxx&#39;)
       * 字符串数组形式的路径 add([&#39;xxx&#39;, &#39;xxx&#39;])
       * 对象数组形式的路径 add([{ name: &#39;xxx&#39;, uri: &#39;xxx&#39; }, { name: &#39;xxx&#39;, uri: &#39;xxx&#39; }])
       */

    }, {
      key: &#39;add&#39;,
      value: function add(uri) {
        if (!isString(uri) &amp;&amp; !isArray(uri)) {
          throw new TypeError(&#39;Just allow Array or String&#39;);
        }
        if (isString(uri)) {
          uri = [{ name: &#39;image$&#39; + this._index, uri: uri }];
        }
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = uri[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var p = _step.value;

            var item = {};
            if (isString(p)) {
              item.name = &#39;image$&#39; + this._index;
              item.uri = p;
            } else {
              if (!p.uri) throw new Error(&#39;Missing image uri&#39;);
              item.name = p.name ? p.name : &#39;image$&#39; + this._index;
              item.uri = p.uri;
            }
            this.list.push(item);
            this._index++;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return this;
      }
<span id='ImageLoader-property-'>      /**
</span>       * 开始加载
       */

    }, {
      key: &#39;load&#39;,
      value: function load() {
        var _this = this;

        if (!this._loading) {
          var _queue;

          (_queue = this.queue).push.apply(_queue, toConsumableArray(this.list));
          this._loading = true;
        }
        if (!this.queue.length) {
          this._loading = false;
          this.compelete(this.success, this.failed);
          return;
        }
        var item = this.queue[0];
        var image = new Image();
        var successFn = function successFn() {
          var cur = _this.queue.shift();
          cur.image = image;
          _this.count++;
          _this.success.push(cur);
          _this.progress(_this.count / _this.list.length);
          _this.load();
        };
        var errorFn = function errorFn(err) {
          var cur = _this.queue.shift();
          cur.error = err;
          _this.failed.push(cur);
          console.error(err);
          _this.load();
        };

        image.src = item.uri;

        if (image.complete) {
          successFn();
        } else {
          image.addEventListener(&#39;load&#39;, successFn, false);
          image.addEventListener(&#39;error&#39;, errorFn, false);
        }
      }
    }]);
    return ImageLoader;
  }();

<span id='ImageLoader-method-versionCompare'>  /**
</span>   * 版本号比较
   * @param {String} v1              版本号
   * @param {String} symbol          比较符号 &#39;=&#39; &#39;&gt;&#39; &#39;&lt;&#39; &#39;&gt;=&#39;  &#39;&lt;=&#39;
   * @param {String} v2              版本号
   * @return {boolean}
   */
  function versionCompare(v1, symbol, v2) {
    if (&#39;&gt; &gt;= &lt; &lt;= =&#39;.indexOf(symbol) === -1) {
      throw new Error(&#39;Invalid symbol&#39;);
    }
    if (arguments.length &lt; 3) {
      throw new Error(&#39;At least 3 parameters&#39;);
    }
    if (typeof v1 !== &#39;string&#39; || typeof v2 !== &#39;string&#39;) {
      throw new Error(&#39;Parameters must be String&#39;);
    }
    if (!/^\d+(\.\d+)*$/.test(v1) || !/^\d+(\.\d+)*$/.test(v2)) {
      throw new Error(&#39;Invaild Version Number&#39;);
    }

    var v1Nums = v1.split(&#39;.&#39;).map(function (i) {
      return parseInt(i, 10);
    });
    var v2Nums = v2.split(&#39;.&#39;).map(function (i) {
      return parseInt(i, 10);
    });
    var v1NumsLen = v1Nums.length;
    var v2NumsLen = v2Nums.length;

    if (v1NumsLen - v2NumsLen &gt; 0) {
      v2Nums.push.apply(v2Nums, toConsumableArray(Array.from(Array(v1NumsLen - v2NumsLen), function () {
        return 0;
      })));
    } else if (v1NumsLen - v2NumsLen &lt; 0) {
      v1Nums.push.apply(v1Nums, toConsumableArray(Array.from(Array(v2NumsLen - v1NumsLen), function () {
        return 0;
      })));
    }

    var compare = function compare() {
      for (var i = 0; i &lt; v1Nums.length; i++) {
        if (v1Nums[i] &gt; v2Nums[i]) {
          return &#39;&gt;&#39;;
        } else if (v1Nums[i] &lt; v2Nums[i]) {
          return &#39;&lt;&#39;;
        }
      }
      return &#39;=&#39;;
    };

    return symbol.indexOf(compare()) !== -1;
  }



  var common = /*#__PURE__*/Object.freeze({
    Storage: Storage,
    ImageLoader: ImageLoader,
    versionCompare: versionCompare,
    firstUpper: firstUpper,
    trim: trim,
    trimStart: trimStart,
    trimEnd: trimEnd,
    camelCase: camelCase,
    capitalize: capitalize,
    random: random,
    weightedRandom: weightedRandom,
    list: list,
    randomItem: randomItem,
    deepClone: deepClone
  });

<span id='ImageLoader-property-freeGlobal'>  /** Detect free variable `global` from Node.js. */
</span>  var freeGlobal = (typeof global === &#39;undefined&#39; ? &#39;undefined&#39; : _typeof(global)) == &#39;object&#39; &amp;&amp; global !== null &amp;&amp; global.Object === Object &amp;&amp; global;

<span id='ImageLoader-property-freeSelf'>  /** Detect free variable `self`. */
</span>  var freeSelf = (typeof self === &#39;undefined&#39; ? &#39;undefined&#39; : _typeof(self)) == &#39;object&#39; &amp;&amp; self !== null &amp;&amp; self.Object === Object &amp;&amp; self;

<span id='ImageLoader-property-root'>  /** Used as a reference to the global object. */
</span>  var root = freeGlobal || freeSelf || Function(&#39;return this&#39;)();

<span id='ImageLoader-method-debounce'>  /**
</span>   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked, or until the next browser frame is drawn. The debounced function
   * comes with a `cancel` method to cancel delayed `func` invocations and a
   * `flush` method to immediately invoke them. Provide `options` to indicate
   * whether `func` should be invoked on the leading and/or trailing edge of the
   * `wait` timeout. The `func` is invoked with the last arguments provided to the
   * debounced function. Subsequent calls to the debounced function return the
   * result of the last `func` invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`
   * invocation will be deferred until the next frame is drawn (typically about
   * 16ms).
   *
   * See [David Corbacho&#39;s article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `debounce` and `throttle`.
   *
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0]
   *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is
   *  used (if available).
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it&#39;s invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on(&#39;resize&#39;, debounce(calculateLayout, 150))
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on(&#39;click&#39;, debounce(sendMail, 300, {
   *   &#39;leading&#39;: true,
   *   &#39;trailing&#39;: false
   * }))
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * const debounced = debounce(batchLog, 250, { &#39;maxWait&#39;: 1000 })
   * const source = new EventSource(&#39;/stream&#39;)
   * jQuery(source).on(&#39;message&#39;, debounced)
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on(&#39;popstate&#39;, debounced.cancel)
   *
   * // Check for pending invocations.
   * const status = debounced.pending() ? &quot;Pending...&quot; : &quot;Ready&quot;
   */
  function debounce(func, wait, options) {
    var lastArgs = void 0,
        lastThis = void 0,
        maxWait = void 0,
        result = void 0,
        timerId = void 0,
        lastCallTime = void 0;

    var lastInvokeTime = 0;
    var leading = false;
    var maxing = false;
    var trailing = true;

    // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.
    var useRAF = !wait &amp;&amp; wait !== 0 &amp;&amp; typeof root.requestAnimationFrame === &#39;function&#39;;

    if (typeof func != &#39;function&#39;) {
      throw new TypeError(&#39;Expected a function&#39;);
    }
    wait = +wait || 0;
    if (isObject(options)) {
      leading = !!options.leading;
      maxing = &#39;maxWait&#39; in options;
      maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait;
      trailing = &#39;trailing&#39; in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs;
      var thisArg = lastThis;

      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function startTimer(pendingFunc, wait) {
      if (useRAF) {
        return root.requestAnimationFrame(pendingFunc);
      }
      return setTimeout(pendingFunc, wait);
    }

    function cancelTimer(id) {
      if (useRAF) {
        return root.cancelAnimationFrame(id);
      }
      clearTimeout(id);
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time;
      // Start the timer for the trailing edge.
      timerId = startTimer(timerExpired, wait);
      // Invoke the leading edge.
      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime;
      var timeSinceLastInvoke = time - lastInvokeTime;
      var timeWaiting = wait - timeSinceLastCall;

      return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime;
      var timeSinceLastInvoke = time - lastInvokeTime;

      // Either this is the first call, activity has stopped and we&#39;re at the
      // trailing edge, the system time has gone backwards and we&#39;re treating
      // it as the trailing edge, or we&#39;ve hit the `maxWait` limit.
      return lastCallTime === undefined || timeSinceLastCall &gt;= wait || timeSinceLastCall &lt; 0 || maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait;
    }

    function timerExpired() {
      var time = Date.now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      // Restart the timer.
      timerId = startTimer(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined;

      // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.
      if (trailing &amp;&amp; lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        cancelTimer(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(Date.now());
    }

    function pending() {
      return timerId !== undefined;
    }

    function debounced() {
      var time = Date.now();
      var isInvoking = shouldInvoke(time);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key &lt; _len; _key++) {
        args[_key] = arguments[_key];
      }

      lastArgs = args;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          // Handle invocations in a tight loop.
          timerId = startTimer(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === undefined) {
        timerId = startTimer(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    debounced.pending = pending;
    return debounced;
  }

<span id='ImageLoader-method-throttle'>  /**
</span>   * Creates a throttled function that only invokes `func` at most once per
   * every `wait` milliseconds (or once per browser frame). The throttled function
   * comes with a `cancel` method to cancel delayed `func` invocations and a
   * `flush` method to immediately invoke them. Provide `options` to indicate
   * whether `func` should be invoked on the leading and/or trailing edge of the
   * `wait` timeout. The `func` is invoked with the last arguments provided to the
   * throttled function. Subsequent calls to the throttled function return the
   * result of the last `func` invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the throttled function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`
   * invocation will be deferred until the next frame is drawn (typically about
   * 16ms).
   *
   * See [David Corbacho&#39;s article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `throttle` and `debounce`.
   *
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to throttle.
   * @param {number} [wait=0]
   *  The number of milliseconds to throttle invocations to; if omitted,
   *  `requestAnimationFrame` is used (if available).
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=true]
   *  Specify invoking on the leading edge of the timeout.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new throttled function.
   * @example
   *
   * // Avoid excessively updating the position while scrolling.
   * jQuery(window).on(&#39;scroll&#39;, throttle(updatePosition, 100))
   *
   * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
   * const throttled = throttle(renewToken, 300000, { &#39;trailing&#39;: false })
   * jQuery(element).on(&#39;click&#39;, throttled)
   *
   * // Cancel the trailing throttled invocation.
   * jQuery(window).on(&#39;popstate&#39;, throttled.cancel)
   */
  function throttle(func, wait, options) {
    var leading = true;
    var trailing = true;

    if (typeof func != &#39;function&#39;) {
      throw new TypeError(&#39;Expected a function&#39;);
    }
    if (isObject(options)) {
      leading = &#39;leading&#39; in options ? !!options.leading : leading;
      trailing = &#39;trailing&#39; in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
      &#39;leading&#39;: leading,
      &#39;maxWait&#39;: wait,
      &#39;trailing&#39;: trailing
    });
  }



  var lib = /*#__PURE__*/Object.freeze({
    debounce: debounce,
    throttle: throttle
  });

  // const Z = {};
  // const addDefault = (o) =&gt; {
  //   Object.keys(o).forEach((v) =&gt; {
  //     Z[v] = o[v];
  //   });
  // };

  // addDefault(module);
  // addDefault(type);
  // addDefault(common);

  // export default Z;
  var index = Object.assign({}, module$1, type, common, lib);

  exports.default = index;
  exports.env = env;
  exports.wxPreviewImage = wxPreviewImage;
  exports.is = is;
  exports.isString = isString;
  exports.isNumberString = isNumberString;
  exports.isFunction = isFunction;
  exports.isBoolean = isBoolean;
  exports.isNull = isNull;
  exports.isUndefined = isUndefined;
  exports.isArray = isArray;
  exports.isEmptyArray = isEmptyArray;
  exports.isEmptyObjectLike = isEmptyObjectLike;
  exports.isObject = isObject;
  exports.isObjectLike = isObjectLike;
  exports.isEmptyObject = isEmptyObject;
  exports.isNumber = isNumber;
  exports.isFloatNumber = isFloatNumber;
  exports.isEvenNumber = isEvenNumber;
  exports.Storage = Storage;
  exports.ImageLoader = ImageLoader;
  exports.versionCompare = versionCompare;
  exports.firstUpper = firstUpper;
  exports.trim = trim;
  exports.trimStart = trimStart;
  exports.trimEnd = trimEnd;
  exports.camelCase = camelCase;
  exports.capitalize = capitalize;
  exports.random = random;
  exports.weightedRandom = weightedRandom;
  exports.list = list;
  exports.randomItem = randomItem;
  exports.deepClone = deepClone;
  exports.debounce = debounce;
  exports.throttle = throttle;

  Object.defineProperty(exports, &#39;__esModule&#39;, { value: true });

})));
</pre>
</body>
</html>
